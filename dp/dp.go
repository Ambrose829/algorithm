package dp

/**
  @Author: pika
  @Date: 2022/1/20 9:15 下午
  @Description: 动态规划（Dynamic Programming）
*/

/*
 	首先，动态规划问题的一般形式就是求最值。比如让你求最长递增子序列、最小编辑距离等。
	既然是求最值，核心问题是什么呢？ 求解动态规划的核心问题是穷举。
	动态规划的穷举有点特别，因为这类问题存在「重叠子问题」，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。
	动态规划问题一定会具备「最优子结构」，才通过子问题的最值得到原问题的最值
	核心：需要列出正确的「状态转移方程」

	状态转移方程：
	明确base case --> 明确「状态」 --> 明确「选择」--> 定义dp数组/函数的含义
	```
	# 初始化 base case
	dp[0][0][...] = base
	# 进行状态转移
	for 状态1 in 状态1的所有取值:
		for 状态2 in 状态2的所有取值:
			for ...
				dp[状态1][状态2][...] = 求最值(选择1，选择2...)
	```

	动态规划技巧: 「状态压缩」，如果我们发现每次状态转移只需要DP table 中的一部分，那么可以尝试用状态压缩来缩小DP table的大小，只记录必要的数据。
 */


/*
	*带备忘录的递归算法与动态规划
	带备忘录的递归算法，把一颗存在巨量冗余的递归树通过「剪枝」，改造成一副不存在冗余的递归图，极大减少了子问题（递归结点）的个数。

	带备忘录的递归算法效率和迭代的动态规划解法一样了。这种解法已经与动态规划相差不多，这种方法叫做「自顶向下」，动态规划叫做「自底向上」
	「自顶向下」
	从上向下延伸，从一个规模较大的问题比如说f(20),向下逐渐分解规模，直到f(1)和f(2)这两个base case，然后逐层返回答案。
	「自底向上」
	反过来，我们直接从最底下，最简单，问题规模最小的f(1)和f(2)开始往上推，直到推到我们想要的答案f(20)。
 */